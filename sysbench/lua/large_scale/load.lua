-- like MAX_INT, but Lua uses doubles
LARGE_INT = 2^30


local thread_time_keepalive = os.time()
function parallel_prepare(thread_id, num_threads)
    if thread_id > sysbench.opt.num_collections then
        return
    end
    local my_num_collections = math.floor(sysbench.opt.num_collections / num_threads)
    -- share the remainder so that each thread gets one each, starting with thread_id 0
    if thread_id <  sysbench.opt.num_collections % num_threads then
        my_num_collections = my_num_collections + 1
    end
    -- second term is to account for the remainder
    local my_first_collection = thread_id * my_num_collections
    -- For threads larger than the remainder, my_num_collections is 1 smaller, so compensate and add the remainder back
    if thread_id >= sysbench.opt.num_collections % num_threads then
        my_first_collection = my_first_collection + sysbench.opt.num_collections % num_threads
    end
    local my_last_collection = my_first_collection +my_num_collections - 1
    if sysbench.opt.verbosity >= 3 then
        print("load: thread_id " .. thread_id .. " / " .. num_threads-1 .. " has collections " .. my_first_collection .. " - " .. my_last_collection)
    end
    -- unlike python, lua includes the last parameter to for
    for n=my_first_collection, my_last_collection do
        -- print progress every 5 min. Among other things to avoid timeouts.
        if os.time() > thread_time_keepalive + 5*60 or
                sysbench.opt.verbosity >= 4 then

            print("thread_id " .. thread_id .. " collection " .. n .. "/" .. my_last_collection)
            thread_time_keepalive = os.time()
        end
        local coll = getCollection(n)
        coll:drop()
        if sysbench.opt.indexes_last == "no" then
            if thread_id == 0 and n == 0 then
                print("Creating indexes first")
            end
            create_indexes1(sysbench.opt.collection_name .. n)
        end
        local num_batches = math.floor(sysbench.opt.num_docs / sysbench.opt.batch_size)
        local remainder_start = num_batches * sysbench.opt.batch_size + 1
        local remainder_docs = sysbench.opt.num_docs % sysbench.opt.batch_size
        for b=0, num_batches-1 do
            if os.time() > thread_time_keepalive + 5*60 or
                    sysbench.opt.verbosity >= 4 then

                print("thread_id " .. thread_id .. " collection " .. n .. "/" .. (my_num_collections + my_first_collection - 1) .. " batch " .. b .. "/" .. (num_batches-1))
                thread_time_keepalive = os.time()
            end
            local start_id = b * sysbench.opt.batch_size + 1
            local stop_id = start_id + sysbench.opt.batch_size - 1
            usleep(sysbench.opt.loader_sleep*1000*1000)
            do_batch(coll, start_id, stop_id)
        end
        if sysbench.opt.verbosity >= 4 then
            print("thread_id " .. thread_id .. " collection " .. n .. " remainder_start " .. remainder_start .. " remainder_stop " .. remainder_start + remainder_docs - 1)
        end
        do_batch(coll, remainder_start, remainder_start + remainder_docs - 1)
        if sysbench.opt.indexes_last == "yes" then
            if thread_id == 0 and n == 0 then
                print("Creating indexes last")
            end
            create_indexes(sysbench.opt.collection_name .. n)
        end
    end
end

function create_indexes1(coll_name)
    -- some mongorover error simply from calling db:command() now. Really would need a bit of a refresh on mongorover...
    -- the index does get created though. pcall() is like try-catch for lua.
    pcall(create_index, coll_name, "t_1_w_1", {t = 1, w = 1})
    pcall(create_index, coll_name, "y_1", {y = 1})
    pcall(create_index, coll_name, "t_1_stringShort_1", {t = 1, stringShort = 1})
    pcall(create_index, coll_name, "string0_1", {string0 = 1})
    pcall(create_index, coll_name, "stringLong_1", {stringLong = 1}, true)
--     pcall(create_index, coll_name, "stringShort_y_1", {stringShort = 1, y = 1})
--     pcall(create_index, coll_name, "int0_1_int1_1_int2_1", {int0 = 1, int1 = 1, int2 = 1})
--     pcall(create_index, coll_name, "int3_1", {int3 = 1})
--     pcall(create_index, coll_name, "int4_1", {int4 = 1})
--     pcall(create_index, coll_name, "int5_1_int6_1", {int5 = 1, int6 = 1})
end

function create_indexes(coll_name)
    -- some mongorover error simply from calling db:command() now. Really would need a bit of a refresh on mongorover...
    -- the index does get created though. pcall() is like try-catch for lua.
    -- mongorover limitation: index name is required, not autogenerated.
    local indexes = {
        { key = {t = 1, w = 1}, name = "t_1_w_1" },
        { key = {y = 1}, name = "y_1" },
        { key = {t = 1, stringShort = 1}, name = "t_1_stringShort_1" },
        { key = {string0 = 1}, name = "string0_1" },
        { key = {stringLong = 1}, name = "stringLong_1", unique = true },
--         { key = {stringShort = 1, y = 1}, name = "stringShort_y_1" },
--         { key = {int0 = 1, int1 = 1, int2 = 1}, name = "int0_1_int1_1_int2_1" },
--         { key = {int3 = 1}, name =  "int3_1"},
--         { key = {int4 = 1}, name =  "int4_1"},
--         { key = {int5 = 1, int6 = 1}, name =  "int5_1_int6_1"}
    }
    --     create_all_indexes(coll_name, indexes)
    pcall(create_all_indexes, coll_name, indexes)

end

function create_index(coll_name, index_name, index_spec, unique)
    local unique = unique or false
    if sysbench.opt.verbosity >= 5 then
        print("collection " .. coll_name .. " create_index " .. field_name)
    end
    local db = getDB()
    -- mongorover limitation: index name is required, not autogenerated.
    db:command("createIndexes", coll_name, { indexes = {{ key = index_spec, name = index_name, unique = unique }}})
end

function create_all_indexes(coll_name, indexes)
    if sysbench.opt.verbosity >= 4 then
        print("collection " .. coll_name .. " create_all_indexes")
    end
    local db = getDB()
    db:command("createIndexes", coll_name, { indexes = indexes, writeConcern = {w = "majority"} })
end

function generate_doc(id)
    local doc = {_id = id,
           t = sysbench.rand.uniform(0, 10),
           w = sysbench.rand.pareto(0, 10000000),
           x = 0,
           y = sysbench.rand.uniform(0, 1000),
           z = sysbench.rand.uniform(0, LARGE_INT),
           int0 = sysbench.rand.gaussian(0, 200),
           int1 = sysbench.rand.gaussian(0, 200),
           int2 = sysbench.rand.gaussian(0, 200),
           int3 = sysbench.rand.gaussian(0, 200),
           int4 = sysbench.rand.gaussian(0, 200),
           int5 = sysbench.rand.gaussian(0, 200),
           int6 = sysbench.rand.gaussian(0, 200),
           int7 = sysbench.rand.gaussian(0, 200),
           int8 = sysbench.rand.gaussian(0, 200),
           int9 = sysbench.rand.gaussian(0, 200),
           intArray = {{
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
               sysbench.rand.uniform(0, 10000),
           }},
           string0 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string1 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string2 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string3 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string4 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string5 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string6 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string7 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string8 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           string9 = sysbench.rand.string(string.rep("@", sysbench.rand.uniform(5, 15))),
           stringShort = sysbench.rand.string("@"),
           stringLong = sysbench.rand.string(string.rep("@", 100)),
           compressibleStringArray = {{
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA",
               "AAAAAAAAAAAAAAAAAAAA"
           }},
          some = {embedded = {document = {with = {some = {depth = sysbench.rand.string("@@@@@@@@@@")}}}}}
    }
    return doc
end

function do_batch(coll, start_id, stop_id)
    if sysbench.opt.verbosity >= 4 then
        print("do_batch(" .. sysbench.tid .. "," .. start_id .. "," .. stop_id .. ")")
    end
    if start_id > stop_id then
        return
    end

    local arrayOfDocuments = {}
    for i=start_id, stop_id do
        arrayOfDocuments[#arrayOfDocuments+1] = generate_doc(i)
    end
    if sysbench.opt.verbosity >= 5 then
        pretty.dump(arrayOfDocuments)
    end
    local result = coll:insert_many(arrayOfDocuments)
    if sysbench.opt.verbosity >= 5 then
        pretty.dump(result)
    end
    if result then
        ffi.C.sb_counter_inc(sysbench.tid, ffi.C.SB_CNT_WRITE)
        for n = 1, sysbench.opt.batch_size do
        end
    else
        ffi.C.sb_counter_inc(sysbench.tid, ffi.C.SB_CNT_ERROR)
    end
end

function set_oplog_size(bytes)
    pcall(set_oplog_size_wrapper, bytes)
end

function set_oplog_size_wrapper(bytes)
    local admin_db = getDB("admin")
    print("Setting oplog size to " .. bytes .. " MB")
    admin_db:command("replSetResizeOplog", "rs.oplog", {size = bytes})
end